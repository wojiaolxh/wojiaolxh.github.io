<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>原型、原型链 | 勿忘的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/avatar.png">
    <meta name="description" content="网站描述">
    
    <link rel="preload" href="/assets/css/0.styles.b23bcaa9.css" as="style"><link rel="preload" href="/assets/js/app.f1c655d9.js" as="script"><link rel="preload" href="/assets/js/2.5f75bc7c.js" as="script"><link rel="preload" href="/assets/js/25.c9dbf47b.js" as="script"><link rel="prefetch" href="/assets/js/10.a71d7304.js"><link rel="prefetch" href="/assets/js/11.6f94e497.js"><link rel="prefetch" href="/assets/js/12.0d179624.js"><link rel="prefetch" href="/assets/js/13.e9a89278.js"><link rel="prefetch" href="/assets/js/14.7d41ea20.js"><link rel="prefetch" href="/assets/js/15.c14d442c.js"><link rel="prefetch" href="/assets/js/16.8a2ee272.js"><link rel="prefetch" href="/assets/js/17.a683bc65.js"><link rel="prefetch" href="/assets/js/18.7bd3e1ed.js"><link rel="prefetch" href="/assets/js/19.0d723740.js"><link rel="prefetch" href="/assets/js/20.d18ca8a4.js"><link rel="prefetch" href="/assets/js/21.22b75bfe.js"><link rel="prefetch" href="/assets/js/22.7e6fb782.js"><link rel="prefetch" href="/assets/js/23.9002abe0.js"><link rel="prefetch" href="/assets/js/24.7e00f53a.js"><link rel="prefetch" href="/assets/js/26.f116f6c6.js"><link rel="prefetch" href="/assets/js/27.553a66cd.js"><link rel="prefetch" href="/assets/js/28.a17b96a4.js"><link rel="prefetch" href="/assets/js/29.5b6ed7a7.js"><link rel="prefetch" href="/assets/js/3.b77b1dc1.js"><link rel="prefetch" href="/assets/js/30.cdb3c8c7.js"><link rel="prefetch" href="/assets/js/31.6280fb91.js"><link rel="prefetch" href="/assets/js/32.0ef13458.js"><link rel="prefetch" href="/assets/js/33.d5779eeb.js"><link rel="prefetch" href="/assets/js/34.7375a1d9.js"><link rel="prefetch" href="/assets/js/35.b6854634.js"><link rel="prefetch" href="/assets/js/36.4c72afe9.js"><link rel="prefetch" href="/assets/js/37.c4b38050.js"><link rel="prefetch" href="/assets/js/4.053c9f86.js"><link rel="prefetch" href="/assets/js/5.3a29ffe9.js"><link rel="prefetch" href="/assets/js/6.7e1392e3.js"><link rel="prefetch" href="/assets/js/7.1f0c4561.js"><link rel="prefetch" href="/assets/js/8.31476672.js"><link rel="prefetch" href="/assets/js/9.40c7d040.js">
    <link rel="stylesheet" href="/assets/css/0.styles.b23bcaa9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/avatar.png" alt="勿忘的博客" class="logo"> <span class="site-name can-hide">勿忘的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端积累" class="dropdown-title"><span class="title">前端积累</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端积累" class="mobile-dropdown-title"><span class="title">前端积累</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fontend/html/" class="nav-link">
  html css积累
</a></li><li class="dropdown-item"><!----> <a href="/fontend/js/DebounceAndThrottle.html" class="nav-link">
  javascript积累
</a></li><li class="dropdown-item"><!----> <a href="/fontend/vue/" class="nav-link">
  vue积累
</a></li></ul></div></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  前端算法
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端积累" class="dropdown-title"><span class="title">前端积累</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端积累" class="mobile-dropdown-title"><span class="title">前端积累</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/fontend/html/" class="nav-link">
  html css积累
</a></li><li class="dropdown-item"><!----> <a href="/fontend/js/DebounceAndThrottle.html" class="nav-link">
  javascript积累
</a></li><li class="dropdown-item"><!----> <a href="/fontend/vue/" class="nav-link">
  vue积累
</a></li></ul></div></div><div class="nav-item"><a href="/algorithm/" class="nav-link">
  前端算法
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>html</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>js</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fontend/js/DebounceAndThrottle.html" class="sidebar-link">函数防抖和函数节流</a></li><li><a href="/fontend/js/DeclareVariable.html" class="sidebar-link">var和let/const的区别</a></li><li><a href="/fontend/js/ArrowFun.html" class="sidebar-link">箭头函数和普通函数的区别</a></li><li><a href="/fontend/js/ArrayApi.html" class="sidebar-link">数组Api合集</a></li><li><a href="/fontend/js/DataCache.html" class="sidebar-link">浏览器缓存</a></li><li><a href="/fontend/js/RepaintsAndReflow.html" class="sidebar-link">重绘和重排</a></li><li><a href="/fontend/js/CallApplyBind.html" class="sidebar-link">call,apply,bind</a></li><li><a href="/fontend/js/BasicType.html" class="sidebar-link">js基本类型和引用数据类型</a></li><li><a href="/fontend/js/Prototype.html" aria-current="page" class="active sidebar-link">原型、原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/fontend/js/Prototype.html#prototype" class="sidebar-link">prototype</a></li><li class="sidebar-sub-header"><a href="/fontend/js/Prototype.html#原型链" class="sidebar-link">原型链</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="原型、原型链"><a href="#原型、原型链" class="header-anchor">#</a> 原型、原型链</h1> <h2 id="prototype"><a href="#prototype" class="header-anchor">#</a> prototype</h2> <h3 id="只有函数有prototype属性"><a href="#只有函数有prototype属性" class="header-anchor">#</a> 只有函数有prototype属性</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token function-variable function">b</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// { constructor: function(){...} }</span>
</code></pre></div><h5 id="object-prototype怎么解释"><a href="#object-prototype怎么解释" class="header-anchor">#</a> Object.prototype怎么解释？</h5> <p>其实<code>Object</code>是一个全局对象，也是一个构造函数，以及其他基本类型的全局对象也都是构造函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">outTypeName</span><span class="token punctuation">(</span><span class="token parameter">data<span class="token punctuation">,</span> type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> typeName <span class="token operator">=</span>  <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>typeName<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">outTypeName</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span> <span class="token comment">//[object Function]</span>
<span class="token function">outTypeName</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> <span class="token comment">// [object Function]</span>
<span class="token function">outTypeName</span><span class="token punctuation">(</span>Number<span class="token punctuation">)</span> <span class="token comment">// [object Function]</span>
</code></pre></div><h3 id="为什么只有函数有prototype属性"><a href="#为什么只有函数有prototype属性" class="header-anchor">#</a> 为什么只有函数有prototype属性</h3> <p>JS通过<code>new</code>来生成对象，但是仅靠构造函数，每次生成的对象都不一样。
有时候需要在两个对象之间共享属性，由于JS在设计之初没有类的概念，所以JS使用函数的<code>prototype</code>来处理这部分<strong>需要被共享的属性</strong>，通过函数的<code>prototype</code>来模拟类：
当创建一个函数时，JS会自动为函数添加<code>prototype</code>属性，值是一个有<code>constructor</code>的对象。
以下是共享属性<code>prototype</code>的栗子：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">People</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token class-name">People</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">23</span> <span class="token comment">// 岁数</span>
<span class="token comment">// 创建两个实例</span>
<span class="token keyword">let</span> People1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">'OBKoro1'</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> People2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token string">'扣肉'</span><span class="token punctuation">)</span>
<span class="token class-name">People</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">24</span> <span class="token comment">// 长大了一岁</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>People1<span class="token punctuation">.</span>age<span class="token punctuation">,</span> People2<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// 24 24</span>
</code></pre></div><p>为什么<code>People1</code>和<code>People2</code>可以访问到<code>People.prototype.age</code>？
原因是：<code>People1</code>和<code>People2</code>的原型是<code>People.prototype</code>，答案在下方的：构造函数是什么以及它做了什么。</p> <h2 id="原型链"><a href="#原型链" class="header-anchor">#</a> 原型链</h2> <h3 id="proto-和object-getprototypeof-target-对象的原型"><a href="#proto-和object-getprototypeof-target-对象的原型" class="header-anchor">#</a> <code>__proto__</code>和<code>Object.getPrototypeOf(target)</code>： 对象的原型</h3> <p><code>__proto__</code>是对象实例和它的构造函数之间建立的链接，它的值是：构造函数的<code>prototype</code>。
也就是说：<code>__proto__</code>的值是它所对应的原型对象，是某个函数的<code>prototype</code> <code>Object.getPrototypeOf(target)</code>全等于<code>__proto__</code>。
<code>Object.getPrototypeOf(target)</code>（读操作）、<code>Object.setPrototypeOf(target)</code>（写操作）、<code>Object.create(target)</code>（生成操作）</p> <h3 id="构造函数是什么、它做了什么"><a href="#构造函数是什么、它做了什么" class="header-anchor">#</a> 构造函数是什么、它做了什么</h3> <p>所谓的构造函数，实际上就是通过关键字new来调用的函数：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> newObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">someFn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 构造调用函数</span>
</code></pre></div><p><strong>构造/new调用函数的时候做了什么：</strong></p> <p>1,创建一个全新的对象。
2,这个新对象的原型(<code>Object.getPrototypeOf(target)</code>)指向构造函数的<code>prototype</code>对象。
3,该函数的this会绑定在新创建的对象上。
4,如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。
5,我们称这个新对象为构造函数的实例。</p> <p><strong>原型继承就是利用构造调用函数的特性：</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 原型继承：SubType继承SuperType</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType <span class="token comment">// 重新指定constructor指向 方便找到构造函数</span>
<span class="token comment">// 挂载SuperType的this和prototype的属性和方法到SubType.prototype上</span>
</code></pre></div><p>1,构造调用的第二点：将新对象的<code>Object.getPrototypeOf(target)</code>指向函数的<code>prototype</code>
2,构造调用的第三点：该函数的this会绑定在新创建的对象上。
3,新对象赋值给<code>SubType.prototype</code></p> <p>原型类型有个缺点：多个实例对引用类型的操作会被篡改。</p> <blockquote><p>因为每次实例化引用类型的数据都指向同一个地址，所以它们读/写的是同一个数据，当一个实例对其进行操作，其他实例的数据就会一起更改。</p></blockquote> <h3 id="原型链是什么"><a href="#原型链是什么" class="header-anchor">#</a> 原型链是什么</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 构造调用foo 返回一个新对象</span>
<span class="token keyword">const</span> newObj__proto__ <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>newObj<span class="token punctuation">)</span> <span class="token comment">// 获取newObj的原型对象</span>
newObj__proto__ <span class="token operator">===</span> foo<span class="token punctuation">.</span>prototype <span class="token comment">// true 验证newObj的原型指向foo</span>
<span class="token keyword">const</span> foo__proto__ <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// 获取foo.prototype的原型</span>
foo__proto__ <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// true foo.prototype的原型是Object.prototype</span>

newObj<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token comment">// 这种关系就是原型链</span>

</code></pre></div><p><strong>可以用以下三句话来理解原型链：</strong></p> <p>1,<strong>每个对象都拥有一个原型对象</strong>: <code>newObj</code>的原型是<code>foo.prototype</code>。</p> <p>2,<strong>对象的原型可能也是继承其他原型对象的</strong>: <code>foo.prototype</code>也有它的原型<code>Object.prototype</code>。</p> <p>3,<strong>一层一层的，以此类推，这种关系就是原型链</strong></p> <h3 id="一个对象是否在另一个对象的原型链上"><a href="#一个对象是否在另一个对象的原型链上" class="header-anchor">#</a> 一个对象是否在另一个对象的原型链上</h3> <blockquote><p>如果一个对象存在另一个对象的原型链上，我们可以说：它们是继承关系。</p></blockquote> <p>根据构造函数的<code>prototype</code>是否在原型链上来判断的：</p> <p>1,<code>instanceof</code>: 用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置
语法：<code>object instanceof constructor</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> testObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
testObject <span class="token keyword">instanceof</span> <span class="token class-name">test</span> <span class="token comment">// true test.prototype在testObject的原型链上</span>
 testObject <span class="token keyword">instanceof</span> <span class="token class-name">Function</span> <span class="token comment">// false Function.prototype 不在testObject的原型链上</span>
testObject <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token comment">// true Object.prototype在testObject的原型链上</span>
</code></pre></div><p>2,<code>isPrototypeOf</code>：测试一个对象是否存在于另一个对象的原型链上
语法：<code>prototypeObj.isPrototypeOf(object)</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> testObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
test<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>testObject<span class="token punctuation">)</span> <span class="token comment">// true test.prototype在testObject的原型链上</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">isPrototypeOf</span><span class="token punctuation">(</span>testObject<span class="token punctuation">)</span> <span class="token comment">// true Object.prototype在testObject的原型链上</span>
</code></pre></div><h3 id="原型链的终点-object-prototype"><a href="#原型链的终点-object-prototype" class="header-anchor">#</a> 原型链的终点: <code>Object.prototype</code></h3> <p><code>Object.prototype</code>是原型链的终点，所有对象都是从它继承了方法和属性。
<code>Object.prototype</code><strong>没有原型对象</strong>：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token comment">// null</span>

</code></pre></div><p><strong>字符串原型链的终点</strong>：<code>Object.prototype</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> test <span class="token operator">=</span> <span class="token string">'由String函数构造出来的'</span>
<span class="token keyword">let</span> stringPrototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> <span class="token comment">// 字符串的原型</span>
stringPrototype <span class="token operator">===</span> <span class="token class-name">String</span><span class="token punctuation">.</span>prototype <span class="token comment">// true 字符串的原型是String对象</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>stringPrototype<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// true String对象的原型是Object对象</span>
</code></pre></div><p><strong>函数原型链的终点</strong>：<code>Object.prototype</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> fnPrototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>
fnPrototype <span class="token operator">===</span> <span class="token class-name">Function</span><span class="token punctuation">.</span>prototype <span class="token comment">// true test的原型是Function.prototype</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// true</span>
</code></pre></div><h3 id="原型链用来做什么"><a href="#原型链用来做什么" class="header-anchor">#</a> 原型链用来做什么？</h3> <h5 id="属性查找"><a href="#属性查找" class="header-anchor">#</a> 属性查找：</h5> <blockquote><p>如果试图访问对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性，以此类推</p></blockquote> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> test <span class="token operator">=</span> <span class="token string">'由String函数构造出来的'</span>
<span class="token keyword">let</span> stringPrototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span> <span class="token comment">// 字符串的原型</span>
stringPrototype <span class="token operator">===</span> <span class="token class-name">String</span><span class="token punctuation">.</span>prototype <span class="token comment">// true 字符串的原型是String对象</span>
Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>stringPrototype<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype <span class="token comment">// true String对象的原型是Object对象</span>
</code></pre></div><p>当你访问<code>test</code>的某个属性时，浏览器会进行以下查找：</p> <p>1,浏览器首先查找<code>test</code> 本身</p> <p>2,接着查找它的原型对象：<code>String.prototype</code></p> <p>3,最后查找<code>String.prototype</code>的原型对象：<code>Object.prototype</code></p> <p>4,一旦在原型链上找到该属性，就会立即返回该属性，停止查找。</p> <p>5,原型链上的原型都没有找到的话，返回<code>undefiend</code></p> <p>这种查找机制还解释了字符串为何会有自带的方法: <code>slice</code>/<code>split</code>/<code>indexOf</code>等。</p> <ul><li>这些属性和方法是定义在<code>String</code>这个全局对象/函数上的。</li> <li>字符串的原型指向了<code>String</code>函数的<code>prototype</code>。</li> <li>之后通过查找原型链，在<code>String</code>函数的<code>prototype</code>中找到这些属性和方法</li></ul> <h5 id="拒绝查找原型链"><a href="#拒绝查找原型链" class="header-anchor">#</a> 拒绝查找原型链：</h5> <p><code>hasOwnProperty</code>: 指示对象自身属性中是否具有指定的属性</p> <p>语法：<code>obj.hasOwnProperty(prop)</code></p> <p>参数: <code>prop</code> 要查找的属性</p> <p>返回值: 用来判断某个对象是否含有指定的属性的<code>Boolean</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> test <span class="token operator">=</span><span class="token punctuation">{</span> <span class="token string">'OBKoro1'</span><span class="token operator">:</span> <span class="token string">'扣肉'</span> <span class="token punctuation">}</span>
test<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'OBKoro1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span>
test<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'toString'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// false test本身没查找到toString </span>
</code></pre></div><p>这个<code>API</code>是挂载在<code>object.prototype</code>上，所有对象都可以使用，API会忽略掉那些从原型链上继承到的属性</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/fontend/js/BasicType.html" class="prev">
        js基本类型和引用数据类型
      </a></span> <span class="next"><a href="/fontend/vue/">
        目录
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.f1c655d9.js" defer></script><script src="/assets/js/2.5f75bc7c.js" defer></script><script src="/assets/js/25.c9dbf47b.js" defer></script>
  </body>
</html>
